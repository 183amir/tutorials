.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_beginner_basics_buildmodel_tutorial.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_beginner_basics_buildmodel_tutorial.py:


`Learn the Basics <intro.html>`_ ||
`Quickstart <quickstart_tutorial.html>`_ || 
`Tensors <tensor_tutorial.html>`_ ||
`Datasets & DataLoaders <data_tutorial.html>`_ ||
`Transforms <transforms_tutorial.html>`_ ||
**Build Model** ||
`Autograd <autograd_tutorial.html>`_ ||
`Optimization <optimization_tutorial.html>`_ ||
`Save & Load Model <saveloadrun_tutorial.html>`_

Build the Neural Network
===================

Neural networks comprise of layers/modules that perform operations on data. 
The `torch.nn <https://pytorch.org/docs/stable/nn.html>`_ namespace provides all the building blocks you need to 
build your own neural network. Every module in PyTorch subclasses the `nn.Module <https://pytorch.org/docs/stable/generated/torch.nn.Module.html>`_. 
A neural network is a module itself that consists of other modules (layers). This nested structure allows for
building and managing complex architectures easily.

In the following sections, we'll build a neural network to classify images in the FashionMNIST dataset.



.. code-block:: default


    import os
    import torch
    from torch import nn
    from torch.utils.data import DataLoader
    from torchvision import datasets, transforms








Get Device for Training
-----------------------
We want to be able to train our model on a hardware accelerator like the GPU, 
if it is available. Let's check to see if 
`torch.cuda <https://pytorch.org/docs/stable/notes/cuda.html>`_ is available, else we 
continue to use the CPU. 


.. code-block:: default


    device = 'cuda' if torch.cuda.is_available() else 'cpu'
    print('Using {} device'.format(device))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Using cuda device


Define the Class
-------------------------
We define our neural network by subclassing ``nn.Module``, and 
initialize the neural network layers in ``__init__``. Every ``nn.Module`` subclass implements
the operations on input data in the ``forward`` method. 


.. code-block:: default


    class NeuralNetwork(nn.Module):
        def __init__(self):
            super(NeuralNetwork, self).__init__()
            self.flatten = nn.Flatten()
            self.linear_relu_stack = nn.Sequential(
                nn.Linear(28*28, 512),
                nn.ReLU(),
                nn.Linear(512, 512),
                nn.ReLU(),
                nn.Linear(512, 10),
                nn.ReLU()
            )

        def forward(self, x):
            x = self.flatten(x)
            logits = self.linear_relu_stack(x)
            return logits







We create an instance of ``NeuralNetwork``, and move it to the ``device``, and print 
it's structure.


.. code-block:: default


    model = NeuralNetwork().to(device)
    print(model)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    NeuralNetwork(
      (flatten): Flatten(start_dim=1, end_dim=-1)
      (linear_relu_stack): Sequential(
        (0): Linear(in_features=784, out_features=512, bias=True)
        (1): ReLU()
        (2): Linear(in_features=512, out_features=512, bias=True)
        (3): ReLU()
        (4): Linear(in_features=512, out_features=10, bias=True)
        (5): ReLU()
      )
    )


To use the model, we pass it the input data. This executes the model's ``forward``,
along with some `background operations <https://github.com/pytorch/pytorch/blob/270111b7b611d174967ed204776985cefca9c144/torch/nn/modules/module.py#L866>`_. 
Do not call ``model.forward()`` directly!

Calling the model on the input returns a 10-dimensional tensor with raw predicted values for each class.
We get the prediction probabilities by passing it through an instance of the ``nn.Softmax`` module.


.. code-block:: default


    X = torch.rand(1, 28, 28, device=device)
    logits = model(X) 
    pred_probab = nn.Softmax(dim=1)(logits)
    y_pred = pred_probab.argmax(1)
    print(f"Predicted class: {y_pred}")






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Predicted class: tensor([9], device='cuda:0')


--------------


Model Layers
-------------------------

Lets break down the layers in the FashionMNIST model. To illustrate it, we 
will take a sample minibatch of 3 images of size 28x28 and see what happens to it as 
we pass it through the network. 


.. code-block:: default


    input_image = torch.rand(3,28,28)
    print(input_image.size())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    torch.Size([3, 28, 28])


nn.Flatten
^^^^^^^^^^^^^^^^^^^^^^
We initialize the `nn.Flatten  <https://pytorch.org/docs/stable/generated/torch.nn.Flatten.html>`_ 
layer to convert each 2D 28x28 image into a contiguous array of 784 pixel values (
the minibatch dimension (at dim=0) is maintained).


.. code-block:: default

 
    flatten = nn.Flatten()
    flat_image = flatten(input_image)
    print(flat_image.size())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    torch.Size([3, 784])


nn.Linear 
^^^^^^^^^^^^^^^^^^^^^^
The `linear layer <https://pytorch.org/docs/stable/generated/torch.nn.Linear.html>`_
is a module that applies a linear transformation on the input using it's stored weights and biases.



.. code-block:: default

    layer1 = nn.Linear(in_features=28*28, out_features=20)
    hidden1 = layer1(flat_image)
    print(hidden1.size())






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    torch.Size([3, 20])


nn.ReLU
^^^^^^^^^^^^^^^^^^^^^^
Non-linear activations are what create the complex mappings between the model's inputs and outputs.
They are applied after linear transformations to introduce *nonlinearity*, helping neural networks
learn a wide variety of phenomena.

In this model, we use `nn.ReLU <https://pytorch.org/docs/stable/generated/torch.nn.ReLU.html>`_ between our
linear layers, but there's other activations to introduce non-linearity in your model.


.. code-block:: default


    print(f"Before ReLU: {hidden1}\n\n")
    hidden1 = nn.ReLU()(hidden1)
    print(f"After ReLU: {hidden1}")







.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Before ReLU: tensor([[-1.4589e-02, -4.7650e-01, -3.9938e-01, -7.0162e-02,  4.5790e-01,
              3.2972e-01, -3.9615e-01,  9.9658e-02, -4.0576e-02, -1.9271e-01,
             -4.9636e-01, -2.6557e-01,  2.8432e-01, -2.4011e-01, -1.8276e-01,
              3.8575e-01,  3.7869e-01, -4.2974e-01, -1.7497e-01,  2.2524e-01],
            [ 4.8246e-01, -2.8880e-01, -4.8839e-01,  7.9067e-02,  1.2279e-01,
              2.4805e-01,  1.6191e-01, -4.1498e-01,  1.0335e-01, -3.9775e-01,
             -6.4374e-01, -3.3494e-01,  2.3972e-01, -6.8068e-02, -2.3483e-01,
              8.1922e-02,  6.4284e-01, -4.3943e-01,  2.0412e-02,  3.1635e-02],
            [ 3.0523e-01, -7.1420e-01, -9.8507e-02, -1.9589e-01,  4.3829e-01,
              4.2439e-01, -2.2314e-01, -3.3925e-01, -3.4661e-01,  1.9288e-02,
             -8.9035e-01, -2.4859e-01,  4.6071e-01, -1.3547e-01, -2.9737e-01,
              3.0717e-01,  6.9789e-01, -5.3084e-01, -9.6476e-02,  6.2782e-04]],
           grad_fn=<AddmmBackward>)


    After ReLU: tensor([[0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 4.5790e-01, 3.2972e-01,
             0.0000e+00, 9.9658e-02, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
             2.8432e-01, 0.0000e+00, 0.0000e+00, 3.8575e-01, 3.7869e-01, 0.0000e+00,
             0.0000e+00, 2.2524e-01],
            [4.8246e-01, 0.0000e+00, 0.0000e+00, 7.9067e-02, 1.2279e-01, 2.4805e-01,
             1.6191e-01, 0.0000e+00, 1.0335e-01, 0.0000e+00, 0.0000e+00, 0.0000e+00,
             2.3972e-01, 0.0000e+00, 0.0000e+00, 8.1922e-02, 6.4284e-01, 0.0000e+00,
             2.0412e-02, 3.1635e-02],
            [3.0523e-01, 0.0000e+00, 0.0000e+00, 0.0000e+00, 4.3829e-01, 4.2439e-01,
             0.0000e+00, 0.0000e+00, 0.0000e+00, 1.9288e-02, 0.0000e+00, 0.0000e+00,
             4.6071e-01, 0.0000e+00, 0.0000e+00, 3.0717e-01, 6.9789e-01, 0.0000e+00,
             0.0000e+00, 6.2782e-04]], grad_fn=<ReluBackward0>)


nn.Sequential
^^^^^^^^^^^^^^^^^^^^^^
`nn.Sequential <https://pytorch.org/docs/stable/generated/torch.nn.Sequential.html>`_ is an ordered 
container of modules. The data is passed through all the modules in the same order as defined. You can use
sequential containers to put together a quick network like ``seq_modules``.


.. code-block:: default


    seq_modules = nn.Sequential(
        flatten,
        layer1,
        nn.ReLU(),
        nn.Linear(20, 10)
    )
    input_image = torch.rand(3,28,28)
    logits = seq_modules(input_image)







nn.Softmax
^^^^^^^^^^^^^^^^^^^^^^
The last linear layer of the neural network returns `logits` - raw values in [-\infty, \infty] - which are passed to the
`nn.Softmax <https://pytorch.org/docs/stable/generated/torch.nn.Softmax.html>`_ module. The logits are scaled to values 
[0, 1] representing the model's predicted probabilities for each class. ``dim`` parameter indicates the dimension along 
which the values must sum to 1. 


.. code-block:: default


    softmax = nn.Softmax(dim=1)
    pred_probab = softmax(logits)








Model Parameters
-------------------------
Many layers inside a neural network are *parameterized*, i.e. have associated weights 
and biases that are optimized during training. Subclassing ``nn.Module`` automatically 
tracks all fields defined inside your model object, and makes all parameters 
accessible using your model's ``parameters()`` or ``named_parameters()`` methods. 

In this example, we iterate over each parameter, and print its size and a preview of its values. 



.. code-block:: default



    print("Model structure: ", model, "\n\n")

    for name, param in model.named_parameters():
        print(f"Layer: {name} | Size: {param.size()} | Values : {param[:2]} \n")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Model structure:  NeuralNetwork(
      (flatten): Flatten(start_dim=1, end_dim=-1)
      (linear_relu_stack): Sequential(
        (0): Linear(in_features=784, out_features=512, bias=True)
        (1): ReLU()
        (2): Linear(in_features=512, out_features=512, bias=True)
        (3): ReLU()
        (4): Linear(in_features=512, out_features=10, bias=True)
        (5): ReLU()
      )
    ) 


    Layer: linear_relu_stack.0.weight | Size: torch.Size([512, 784]) | Values : tensor([[-0.0278,  0.0281, -0.0319,  ..., -0.0275,  0.0036,  0.0173],
            [-0.0247,  0.0330,  0.0018,  ...,  0.0077, -0.0142, -0.0055]],
           device='cuda:0', grad_fn=<SliceBackward>) 

    Layer: linear_relu_stack.0.bias | Size: torch.Size([512]) | Values : tensor([-0.0242,  0.0250], device='cuda:0', grad_fn=<SliceBackward>) 

    Layer: linear_relu_stack.2.weight | Size: torch.Size([512, 512]) | Values : tensor([[ 0.0255,  0.0177, -0.0181,  ..., -0.0026,  0.0386,  0.0085],
            [ 0.0328,  0.0302,  0.0268,  ...,  0.0299, -0.0370,  0.0159]],
           device='cuda:0', grad_fn=<SliceBackward>) 

    Layer: linear_relu_stack.2.bias | Size: torch.Size([512]) | Values : tensor([-0.0138,  0.0345], device='cuda:0', grad_fn=<SliceBackward>) 

    Layer: linear_relu_stack.4.weight | Size: torch.Size([10, 512]) | Values : tensor([[-0.0124, -0.0291, -0.0405,  ..., -0.0389, -0.0364, -0.0007],
            [-0.0347, -0.0423, -0.0176,  ...,  0.0296,  0.0142,  0.0077]],
           device='cuda:0', grad_fn=<SliceBackward>) 

    Layer: linear_relu_stack.4.bias | Size: torch.Size([10]) | Values : tensor([-0.0113, -0.0392], device='cuda:0', grad_fn=<SliceBackward>)


--------------


Further Reading
--------------
- `torch.nn API <https://pytorch.org/docs/stable/nn.html>`_


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  5.862 seconds)


.. _sphx_glr_download_beginner_basics_buildmodel_tutorial.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: buildmodel_tutorial.py <buildmodel_tutorial.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: buildmodel_tutorial.ipynb <buildmodel_tutorial.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.readthedocs.io>`_
